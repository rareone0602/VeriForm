from abc import ABC, abstractmethod
from typing import List, Any, Optional, Protocol, runtime_checkable
from dataclasses import dataclass, field
from veriform.data_collection.reasoning_step import ReasoningChain


@dataclass
class DAGNode:
    node_id: int
    content: str
    formalized_content: Optional[str] = None
    parents: List["DAGNode"] = field(default_factory=list)
    children: List["DAGNode"] = field(default_factory=list)

class DAGModel(ABC):
    @abstractmethod
    def __init__(self, reasoning_chain: ReasoningChain):
        """Build a DAG representation from a reasoning chain."""
        pass

    @abstractmethod
    def __len__(self) -> int:
        """Return number of nodes in the DAG."""
        pass

    @abstractmethod
    def __getitem__(self, key) -> DAGNode:
        """Get a specific node by ID."""
        pass

    @abstractmethod
    def __setitem__(self, key, value) -> None:
        """Set a specific node by ID."""
        pass

class StandardDAGModel(DAGModel):
    LEAN_HEADER = """
-- Lean 4 code generated by VeriForm
import Mathlib
import Aesop

set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat
""".strip()
    def __init__(self, reasoning_chain: ReasoningChain):
        """Concrete implementation of building a DAG from a reasoning chain."""
        # Implementation details would go here
        self.id = reasoning_chain.chain_id
        self.problem_statement = reasoning_chain.problem_statement
        self.final_answer = reasoning_chain.final_answer

        self.nodes = self.build_dag(reasoning_chain)
    
    def build_dag(self, reasoning_chain: ReasoningChain) -> List[DAGNode]:
        """Build DAG nodes from reasoning steps."""
        nodes = []
        for step in reasoning_chain.steps:
            node = DAGNode(
                node_id=step.step_id,
                content=step.content,
                parents=[nodes[p] for p in step.previous_steps]
            )
            nodes.append(node)
        
        for node in nodes:
            for parent_node in node.parents:
                parent_node.children.append(node)
        
        return nodes
    
    def __len__(self) -> int:
        """Return number of nodes in the DAG."""
        return len(self.nodes)

    def __getitem__(self, key) -> DAGNode:
        """Get a specific node by ID."""
        return self.nodes[key]
    
    def __setitem__(self, key, value) -> None:
        """Set a specific node by ID."""
        self.nodes[key] = value

    def lean(self) -> str:
        """Generate Lean code representation of the DAG."""
        ret = self.LEAN_HEADER + "\n\n"
        for node in self.nodes:
            if node.formalized_content is None:
                continue
            ret += f'-- Step {node.node_id}: {node.content}\n'
            ret += node.formalized_content + "\n\n"
        return ret.strip()

if __name__ == "__main__":
    from veriform.data_collection.dataset_loaders import GSM8KLoader
    from pprint import pprint

    gsm8k = GSM8KLoader(split="test", num_samples=1)
    chains = gsm8k.load()
    dag_model = StandardDAGModel(chains[0])
    for chain in chains:
        pprint(chain)
        dag = dag_model.build_dag(chain)
        pprint(dag)